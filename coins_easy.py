"""
Число способов разменять сумму А с помощью N типов монет равно сумме:
    1) Число способов разменять сумму А с помощью всех типов монет, кроме первого типа момент
    2) Число способов разменять сумму (А - D) с использованием всех N типов,
       где D - номинал монеты первого типа

Допущения:

В разбиение может быть 0 монет какого-то типа

Условия:

Если A равно 0 - это значит, что есть только 1 способ размена
Если A меньше 0 - это значит, что есть 0 способов размена
Если N равно 0 - это значит, что есть 0 способов размена


Пример:

Есть монеты номиналом: 1, 5, 10, 25, 50
Необходимо разменять: 20
Количество типов монет: 3

Алгоритм:

1) Выбираем первую тройку типов монет: 1, 5, 10
2) Выбираем любой тип монетки из п.1: 1
3) Так как не знаем количество итераций - подойдет рекурсия.
   Для рекурсии необходимо уменьшение объема данных на каждом шаге.

   Можем выделить 2 этапа:
   1) Считаем количество разбиений, в которых нет монет с номиналом 1
   2) Считаем количество разбиений, в которых есть как минимум 1 монета с номиналом 1

4) Каждый этап является точной копией исходных данных из п.2 - выделяем рекурсивную функцию:

   func(amount, coin_types)

   amount - сумма, которую разбиваем
   coin_types - типа монет, которыми разбиваем

   Получается два рекурсивных вызова:

   func(20, [5, 10]) + func(19, [1, 5, 10])

5) Повторяем до тех пор, пока каждая рекурсия не достигнет базы.
"""


def first_denomination(kinds_of_coins: int) -> int:
    return {
        1: 1,
        2: 5,
        3: 10,
        4: 25,
        5: 50
    }[kinds_of_coins]


def exchanges_count(amount: int, kinds_of_coins: int) -> int:
    if amount == 0:
        return 1
    if amount < 0 or kinds_of_coins == 0:
        return 0

    without_one_coin = exchanges_count(amount, kinds_of_coins - 1)

    without_one_coin_nomination = exchanges_count(amount - first_denomination(kinds_of_coins), kinds_of_coins)

    return without_one_coin + without_one_coin_nomination


if __name__ == '__main__':
    print(exchanges_count(10, 2))
